<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandboxed Escaping</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>A Tale of Sandboxed Isolation Gone Awry</h1>
        <nav>
            <ul>
                <li><a href="https://mister-cyber-chef.github.io/">·Home</a></li>
                <li><a href="bots-and-scrapers.html">·Bots and Scrapers</a></li>
                <li><a href="tokens_and_cookies.html">·A Tale of Tokens, Cookies, and Curious Behaviors</a></li>
                <li><a href="host_header_swap.html">·Host Header Swapping</a></li>
            </ul>
        </nav>
    </header>
    <article>
        <h2>Discovering the Flaw</h2>
        <p>While working on a security assessment for a popular app, I came across something that felt like finding a hidden passage in an otherwise well-guarded castle. The app had a sandboxed environment—a playground for developers to test things without worrying about real user data. At least, that’s how it was supposed to work.</p>

        <p>What I found, however, was a way for these restricted sandbox accounts to peek into the lives of real users on another platform connected to the same ecosystem. It wasn’t something you’d stumble upon by accident—it took some digging and a bit of curiosity. But once I pieced it together, it became clear: this was a serious issue.</p>

        <h3>Piecing It Together</h3>
        <p>Sandboxed environments are designed to be completely isolated. The idea is straightforward—sandbox accounts shouldn’t be able to access anything outside their little bubble, especially not sensitive user data. However, while testing API endpoints, I noticed something odd. When using a sandbox account, I was getting error messages when trying to access certain endpoints. That’s expected. But the errors contained just enough detail to give away that the endpoint <em>existed</em>. It was like a locked door with a small window—enough to make you wonder what was inside.</p>

        <h4>Step 1: Capturing the Token</h4>
        <p>Using Burp Suite, I intercepted the traffic while logging into the app with a sandboxed account. This gave me a session token—a sort of digital key that tells the system who you are and what you’re allowed to do.</p>
        <pre><code>GET /account/verify?info=&amp;options=1&amp;token=ABC[REDACTED] HTTP/2  
Host: api.exampleplatform.com  
User-Agent: Mozilla/5.0</code></pre>
        <p>The response confirmed the token belonged to my sandboxed account. So far, so good.</p>

        <h4>Step 2: Probing Production Endpoints</h4>
        <p>Next, I started testing other endpoints, particularly those related to the platform’s environment. Initially, I hit expected roadblocks, as this user was not intended to be alloweed to view or interact with real legitamate user:</p>
        <pre><code>{
   "issue": {
      "details": "Unsupported. Invalid request or insufficient permissions.",
      "status": 400
   }
}</code></pre>
        <p>But when I targeted endpoints related to publicly visible profiles or user accounts on the sister application, something surprising happened.</p>
        <pre><code>GET /user-profile/67890?info=&amp;options=1&amp;token=ABC[REDACTED] HTTP/2  
Host: api.sisterplatform.com  
User-Agent: Mozilla/5.0</code></pre>
        <p>This time, the response wasn’t an error. Instead, I got a detailed response with metadata about the user, media, and activity references.</p>

        <h3>What Went Wrong?</h3>
        <ol>
            <li><strong>Shared API Infrastructure:</strong> Both the sandbox and production environments used overlapping API logic, allowing accounts from either platform to access shared endpoints.</li>
            <li><strong>Session Token Mismanagement:</strong> Session tokens were valid across platforms, failing to restrict sandbox tokens to the sandbox environment.</li>
            <li><strong>Insufficient Validation:</strong> The production environment didn’t adequately validate the origin of requests.</li>
        </ol>

        <h3>Fixing the Flaw</h3>
        <ul>
            <li><strong>Scoped Tokens:</strong> Ensure session tokens are scoped to their specific environment.</li>
            <li><strong>Stricter Endpoint Validation:</strong> Validate the origin of requests, checking both token and context.</li>
            <li><strong>Segregated Infrastructure:</strong> Separate sandbox and production APIs to minimize interaction risks.</li>
        </ul>

        <h3>Final Thoughts</h3>
        <p>This experience was a reminder that small details can create significant security gaps. Security testing helps uncover these gaps, contributing to stronger, more secure systems. In the end, finding and fixing such issues ensures user trust and system reliability.</p>
    </article>
    <footer>
         <p>&copy; 2024 The Chef's Blog</p>
    </footer>
</body>
</html>
